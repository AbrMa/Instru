CCS PCM C Compiler, Version 4.104, 5967               17-jun.-21 20:19

               Filename: C:\Users\Abraham\Documents\GitHub\Instru\Proyecto final\final\final.lst

               ROM used: 2382 words (29%)
                         Largest free fragment is 2048
               RAM used: 42 (11%) at main() level
                         78 (21%) worst case
               Stack:    2 locations

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f877a.h> // biblioteca del micro 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=10 //adc de 10 bits 
.................... #include <stdio.h> //input output c 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0813:  BCF    03.5
0814:  CLRF   20
0815:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> //floor  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0395:  BCF    54.0
....................    y = x; 
0396:  MOVF   48,W
0397:  MOVWF  4D
0398:  MOVF   47,W
0399:  MOVWF  4C
039A:  MOVF   46,W
039B:  MOVWF  4B
039C:  MOVF   45,W
039D:  MOVWF  4A
....................  
....................    if (x < 0) 
039E:  MOVF   48,W
039F:  MOVWF  58
03A0:  MOVF   47,W
03A1:  MOVWF  57
03A2:  MOVF   46,W
03A3:  MOVWF  56
03A4:  MOVF   45,W
03A5:  MOVWF  55
03A6:  CLRF   5C
03A7:  CLRF   5B
03A8:  CLRF   5A
03A9:  CLRF   59
03AA:  CALL   1ED
03AB:  BTFSS  03.0
03AC:  GOTO   3B1
....................    { 
....................       s = 1; 
03AD:  BSF    54.0
....................       y = -y; 
03AE:  MOVF   4B,W
03AF:  XORLW  80
03B0:  MOVWF  4B
....................    } 
....................  
....................    if (y <= 32768.0) 
03B1:  MOVF   4D,W
03B2:  MOVWF  58
03B3:  MOVF   4C,W
03B4:  MOVWF  57
03B5:  MOVF   4B,W
03B6:  MOVWF  56
03B7:  MOVF   4A,W
03B8:  MOVWF  55
03B9:  CLRF   5C
03BA:  CLRF   5B
03BB:  CLRF   5A
03BC:  MOVLW  8E
03BD:  MOVWF  59
03BE:  CALL   1ED
03BF:  BTFSC  03.0
03C0:  GOTO   3C3
03C1:  BTFSS  03.2
03C2:  GOTO   3DA
....................   res = (float32)(unsigned int16)y; 
03C3:  MOVF   4D,W
03C4:  MOVWF  58
03C5:  MOVF   4C,W
03C6:  MOVWF  57
03C7:  MOVF   4B,W
03C8:  MOVWF  56
03C9:  MOVF   4A,W
03CA:  MOVWF  55
03CB:  CALL   22C
03CC:  MOVF   79,W
03CD:  MOVWF  5A
03CE:  MOVF   78,W
03CF:  MOVWF  59
03D0:  CALL   091
03D1:  MOVF   7A,W
03D2:  MOVWF  51
03D3:  MOVF   79,W
03D4:  MOVWF  50
03D5:  MOVF   78,W
03D6:  MOVWF  4F
03D7:  MOVF   77,W
03D8:  MOVWF  4E
....................  
....................  else if (y < 10000000.0) 
03D9:  GOTO   497
03DA:  MOVF   4D,W
03DB:  MOVWF  58
03DC:  MOVF   4C,W
03DD:  MOVWF  57
03DE:  MOVF   4B,W
03DF:  MOVWF  56
03E0:  MOVF   4A,W
03E1:  MOVWF  55
03E2:  MOVLW  80
03E3:  MOVWF  5C
03E4:  MOVLW  96
03E5:  MOVWF  5B
03E6:  MOVLW  18
03E7:  MOVWF  5A
03E8:  MOVLW  96
03E9:  MOVWF  59
03EA:  CALL   1ED
03EB:  BTFSS  03.0
03EC:  GOTO   48F
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
03ED:  MOVF   4D,W
03EE:  MOVWF  58
03EF:  MOVF   4C,W
03F0:  MOVWF  57
03F1:  MOVF   4B,W
03F2:  MOVWF  56
03F3:  MOVF   4A,W
03F4:  MOVWF  55
03F5:  CLRF   5C
03F6:  CLRF   5B
03F7:  CLRF   5A
03F8:  MOVLW  8E
03F9:  MOVWF  59
03FA:  CALL   123
03FB:  MOVF   7A,W
03FC:  MOVWF  58
03FD:  MOVF   79,W
03FE:  MOVWF  57
03FF:  MOVF   78,W
0400:  MOVWF  56
0401:  MOVF   77,W
0402:  MOVWF  55
0403:  CALL   22C
0404:  MOVF   79,W
0405:  MOVWF  53
0406:  MOVF   78,W
0407:  MOVWF  52
....................       y = 32768.0*(y/32768.0 - (float32)l); 
0408:  MOVF   4D,W
0409:  MOVWF  58
040A:  MOVF   4C,W
040B:  MOVWF  57
040C:  MOVF   4B,W
040D:  MOVWF  56
040E:  MOVF   4A,W
040F:  MOVWF  55
0410:  CLRF   5C
0411:  CLRF   5B
0412:  CLRF   5A
0413:  MOVLW  8E
0414:  MOVWF  59
0415:  CALL   123
0416:  MOVF   77,W
0417:  MOVWF  55
0418:  MOVF   78,W
0419:  MOVWF  56
041A:  MOVF   79,W
041B:  MOVWF  57
041C:  MOVF   7A,W
041D:  MOVWF  58
041E:  MOVF   53,W
041F:  MOVWF  5A
0420:  MOVF   52,W
0421:  MOVWF  59
0422:  CALL   091
0423:  BSF    03.1
0424:  MOVF   58,W
0425:  MOVWF  5C
0426:  MOVF   57,W
0427:  MOVWF  5B
0428:  MOVF   56,W
0429:  MOVWF  5A
042A:  MOVF   55,W
042B:  MOVWF  59
042C:  MOVF   7A,W
042D:  MOVWF  60
042E:  MOVF   79,W
042F:  MOVWF  5F
0430:  MOVF   78,W
0431:  MOVWF  5E
0432:  MOVF   77,W
0433:  MOVWF  5D
0434:  CALL   24B
0435:  CLRF   58
0436:  CLRF   57
0437:  CLRF   56
0438:  MOVLW  8E
0439:  MOVWF  55
043A:  MOVF   7A,W
043B:  MOVWF  5C
043C:  MOVF   79,W
043D:  MOVWF  5B
043E:  MOVF   78,W
043F:  MOVWF  5A
0440:  MOVF   77,W
0441:  MOVWF  59
0442:  CALL   0AE
0443:  MOVF   7A,W
0444:  MOVWF  4D
0445:  MOVF   79,W
0446:  MOVWF  4C
0447:  MOVF   78,W
0448:  MOVWF  4B
0449:  MOVF   77,W
044A:  MOVWF  4A
....................   res = 32768.0*(float32)l; 
044B:  MOVF   53,W
044C:  MOVWF  5A
044D:  MOVF   52,W
044E:  MOVWF  59
044F:  CALL   091
0450:  CLRF   58
0451:  CLRF   57
0452:  CLRF   56
0453:  MOVLW  8E
0454:  MOVWF  55
0455:  MOVF   7A,W
0456:  MOVWF  5C
0457:  MOVF   79,W
0458:  MOVWF  5B
0459:  MOVF   78,W
045A:  MOVWF  5A
045B:  MOVF   77,W
045C:  MOVWF  59
045D:  CALL   0AE
045E:  MOVF   7A,W
045F:  MOVWF  51
0460:  MOVF   79,W
0461:  MOVWF  50
0462:  MOVF   78,W
0463:  MOVWF  4F
0464:  MOVF   77,W
0465:  MOVWF  4E
....................   res += (float32)(unsigned int16)y; 
0466:  MOVF   4D,W
0467:  MOVWF  58
0468:  MOVF   4C,W
0469:  MOVWF  57
046A:  MOVF   4B,W
046B:  MOVWF  56
046C:  MOVF   4A,W
046D:  MOVWF  55
046E:  CALL   22C
046F:  MOVF   79,W
0470:  MOVWF  5A
0471:  MOVF   78,W
0472:  MOVWF  59
0473:  CALL   091
0474:  BCF    03.1
0475:  MOVF   51,W
0476:  MOVWF  5C
0477:  MOVF   50,W
0478:  MOVWF  5B
0479:  MOVF   4F,W
047A:  MOVWF  5A
047B:  MOVF   4E,W
047C:  MOVWF  59
047D:  MOVF   7A,W
047E:  MOVWF  60
047F:  MOVF   79,W
0480:  MOVWF  5F
0481:  MOVF   78,W
0482:  MOVWF  5E
0483:  MOVF   77,W
0484:  MOVWF  5D
0485:  CALL   24B
0486:  MOVF   7A,W
0487:  MOVWF  51
0488:  MOVF   79,W
0489:  MOVWF  50
048A:  MOVF   78,W
048B:  MOVWF  4F
048C:  MOVF   77,W
048D:  MOVWF  4E
....................  } 
....................  
....................  else 
048E:  GOTO   497
....................   res = y; 
048F:  MOVF   4D,W
0490:  MOVWF  51
0491:  MOVF   4C,W
0492:  MOVWF  50
0493:  MOVF   4B,W
0494:  MOVWF  4F
0495:  MOVF   4A,W
0496:  MOVWF  4E
....................  
....................  y = y - (float32)(unsigned int16)y; 
0497:  MOVF   4D,W
0498:  MOVWF  58
0499:  MOVF   4C,W
049A:  MOVWF  57
049B:  MOVF   4B,W
049C:  MOVWF  56
049D:  MOVF   4A,W
049E:  MOVWF  55
049F:  CALL   22C
04A0:  MOVF   79,W
04A1:  MOVWF  5A
04A2:  MOVF   78,W
04A3:  MOVWF  59
04A4:  CALL   091
04A5:  BSF    03.1
04A6:  MOVF   4D,W
04A7:  MOVWF  5C
04A8:  MOVF   4C,W
04A9:  MOVWF  5B
04AA:  MOVF   4B,W
04AB:  MOVWF  5A
04AC:  MOVF   4A,W
04AD:  MOVWF  59
04AE:  MOVF   7A,W
04AF:  MOVWF  60
04B0:  MOVF   79,W
04B1:  MOVWF  5F
04B2:  MOVF   78,W
04B3:  MOVWF  5E
04B4:  MOVF   77,W
04B5:  MOVWF  5D
04B6:  CALL   24B
04B7:  MOVF   7A,W
04B8:  MOVWF  4D
04B9:  MOVF   79,W
04BA:  MOVWF  4C
04BB:  MOVF   78,W
04BC:  MOVWF  4B
04BD:  MOVF   77,W
04BE:  MOVWF  4A
....................  
....................  if (s) 
04BF:  BTFSS  54.0
04C0:  GOTO   4C4
....................   res = -res; 
04C1:  MOVF   4F,W
04C2:  XORLW  80
04C3:  MOVWF  4F
....................  
....................  if (y != 0) 
04C4:  MOVF   4D,W
04C5:  MOVWF  58
04C6:  MOVF   4C,W
04C7:  MOVWF  57
04C8:  MOVF   4B,W
04C9:  MOVWF  56
04CA:  MOVF   4A,W
04CB:  MOVWF  55
04CC:  CLRF   5C
04CD:  CLRF   5B
04CE:  CLRF   5A
04CF:  CLRF   59
04D0:  CALL   1ED
04D1:  BTFSC  03.2
04D2:  GOTO   50A
....................  { 
....................   if (s == 1 && n == 0) 
04D3:  BTFSS  54.0
04D4:  GOTO   4EF
04D5:  MOVF   49,F
04D6:  BTFSS  03.2
04D7:  GOTO   4EF
....................    res -= 1.0; 
04D8:  BSF    03.1
04D9:  MOVF   51,W
04DA:  MOVWF  5C
04DB:  MOVF   50,W
04DC:  MOVWF  5B
04DD:  MOVF   4F,W
04DE:  MOVWF  5A
04DF:  MOVF   4E,W
04E0:  MOVWF  59
04E1:  CLRF   60
04E2:  CLRF   5F
04E3:  CLRF   5E
04E4:  MOVLW  7F
04E5:  MOVWF  5D
04E6:  CALL   24B
04E7:  MOVF   7A,W
04E8:  MOVWF  51
04E9:  MOVF   79,W
04EA:  MOVWF  50
04EB:  MOVF   78,W
04EC:  MOVWF  4F
04ED:  MOVF   77,W
04EE:  MOVWF  4E
....................  
....................   if (s == 0 && n == 1) 
04EF:  BTFSC  54.0
04F0:  GOTO   50A
04F1:  DECFSZ 49,W
04F2:  GOTO   50A
....................    res += 1.0; 
04F3:  BCF    03.1
04F4:  MOVF   51,W
04F5:  MOVWF  5C
04F6:  MOVF   50,W
04F7:  MOVWF  5B
04F8:  MOVF   4F,W
04F9:  MOVWF  5A
04FA:  MOVF   4E,W
04FB:  MOVWF  59
04FC:  CLRF   60
04FD:  CLRF   5F
04FE:  CLRF   5E
04FF:  MOVLW  7F
0500:  MOVWF  5D
0501:  CALL   24B
0502:  MOVF   7A,W
0503:  MOVWF  51
0504:  MOVF   79,W
0505:  MOVWF  50
0506:  MOVF   78,W
0507:  MOVWF  4F
0508:  MOVF   77,W
0509:  MOVWF  4E
....................  } 
....................  if (x == 0) 
050A:  MOVF   48,W
050B:  MOVWF  58
050C:  MOVF   47,W
050D:  MOVWF  57
050E:  MOVF   46,W
050F:  MOVWF  56
0510:  MOVF   45,W
0511:  MOVWF  55
0512:  CLRF   5C
0513:  CLRF   5B
0514:  CLRF   5A
0515:  CLRF   59
0516:  CALL   1ED
0517:  BTFSS  03.2
0518:  GOTO   51D
....................     res = 0; 
0519:  CLRF   51
051A:  CLRF   50
051B:  CLRF   4F
051C:  CLRF   4E
....................  
....................  return (res); 
051D:  MOVF   4E,W
051E:  MOVWF  77
051F:  MOVF   4F,W
0520:  MOVWF  78
0521:  MOVF   50,W
0522:  MOVWF  79
0523:  MOVF   51,W
0524:  MOVWF  7A
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
038C:  MOVF   44,W
038D:  MOVWF  48
038E:  MOVF   43,W
038F:  MOVWF  47
0390:  MOVF   42,W
0391:  MOVWF  46
0392:  MOVF   41,W
0393:  MOVWF  45
0394:  CLRF   49
.................... } 
*
0525:  BSF    0A.3
0526:  BCF    0A.4
0527:  GOTO   0B2 (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, PUT, BROWNOUT 
.................... #use delay (clock = 4MHz) // XT = 4MHz 
.................... #use rs232 (baud = 9600, parity = N, xmit = pin_c6, rcv = pin_c7, bits = 8 ) // configuracin del puerto serial 
....................  
.................... #define echo PIN_B0 
.................... #define trigger PIN_B1 
....................  
.................... void main () { 
*
0046:  DATA 00,00
*
0800:  CLRF   04
0801:  BCF    03.7
0802:  MOVLW  1F
0803:  ANDWF  03,F
0804:  MOVLW  19
0805:  BSF    03.5
0806:  MOVWF  19
0807:  MOVLW  A6
0808:  MOVWF  18
0809:  MOVLW  90
080A:  BCF    03.5
080B:  MOVWF  18
080C:  BSF    03.5
080D:  BSF    1F.0
080E:  BSF    1F.1
080F:  BSF    1F.2
0810:  BCF    1F.3
0811:  MOVLW  07
0812:  MOVWF  1C
....................  
....................    float distancia, voltajeTemperatura, temperatura, voltajeHS, HS; 
....................    double tiempo; 
....................    int16 duty, LSB; 
....................    int Timer2, poscaler; 
....................  
....................    setup_adc_ports(all_analog); 
*
0818:  BSF    03.5
0819:  BCF    1F.0
081A:  BCF    1F.1
081B:  BCF    1F.2
081C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_internal); 
081D:  BCF    1F.6
081E:  BCF    03.5
081F:  BSF    1F.6
0820:  BSF    1F.7
0821:  BSF    03.5
0822:  BSF    1F.7
0823:  BCF    03.5
0824:  BSF    1F.0
....................  
....................    setup_timer_1(T1_internal|T1_div_by_1); 
0825:  MOVLW  85
0826:  MOVWF  10
....................    Timer2=249; 
0827:  MOVLW  F9
0828:  MOVWF  3F
....................  
....................    poscaler=1; 
0829:  MOVLW  01
082A:  MOVWF  40
....................    set_tris_c(0b11111110); 
082B:  MOVLW  FE
082C:  BSF    03.5
082D:  MOVWF  07
082E:  BCF    03.5
082F:  MOVWF  22
....................    setup_ccp1 (ccp_pwm); 
0830:  BCF    22.2
0831:  MOVF   22,W
0832:  BSF    03.5
0833:  MOVWF  07
0834:  BCF    03.5
0835:  BCF    07.2
0836:  MOVLW  0C
0837:  MOVWF  17
....................    duty=0; 
0838:  CLRF   3C
0839:  CLRF   3B
....................  
....................    while (true) { 
....................       printf("-------------------------------\r\n"); 
083A:  MOVLW  04
083B:  BSF    03.6
083C:  MOVWF  0D
083D:  MOVLW  00
083E:  MOVWF  0F
083F:  BCF    0A.3
0840:  BCF    03.6
0841:  GOTO   047
0842:  BSF    0A.3
....................       //Temperatura 
....................       set_adc_channel(1); 
0843:  MOVLW  08
0844:  MOVWF  78
0845:  MOVF   1F,W
0846:  ANDLW  C7
0847:  IORWF  78,W
0848:  MOVWF  1F
....................       delay_us(10); 
0849:  MOVLW  03
084A:  MOVWF  77
084B:  DECFSZ 77,F
084C:  GOTO   04B
....................       LSB = read_adc(); 
084D:  BSF    1F.2
084E:  BTFSC  1F.2
084F:  GOTO   04E
0850:  BSF    03.5
0851:  MOVF   1E,W
0852:  BCF    03.5
0853:  MOVWF  3D
0854:  MOVF   1E,W
0855:  MOVWF  3E
....................       voltajeTemperatura = (LSB * 5.0) / 1023.0; 
0856:  MOVF   3E,W
0857:  MOVWF  5A
0858:  MOVF   3D,W
0859:  MOVWF  59
085A:  BCF    0A.3
085B:  CALL   091
085C:  BSF    0A.3
085D:  MOVF   7A,W
085E:  MOVWF  58
085F:  MOVF   79,W
0860:  MOVWF  57
0861:  MOVF   78,W
0862:  MOVWF  56
0863:  MOVF   77,W
0864:  MOVWF  55
0865:  CLRF   5C
0866:  CLRF   5B
0867:  MOVLW  20
0868:  MOVWF  5A
0869:  MOVLW  81
086A:  MOVWF  59
086B:  BCF    0A.3
086C:  CALL   0AE
086D:  BSF    0A.3
086E:  MOVF   77,W
086F:  MOVWF  41
0870:  MOVF   78,W
0871:  MOVWF  42
0872:  MOVF   79,W
0873:  MOVWF  43
0874:  MOVF   7A,W
0875:  MOVWF  44
0876:  MOVWF  58
0877:  MOVF   43,W
0878:  MOVWF  57
0879:  MOVF   42,W
087A:  MOVWF  56
087B:  MOVF   41,W
087C:  MOVWF  55
087D:  CLRF   5C
087E:  MOVLW  C0
087F:  MOVWF  5B
0880:  MOVLW  7F
0881:  MOVWF  5A
0882:  MOVLW  88
0883:  MOVWF  59
0884:  BCF    0A.3
0885:  CALL   123
0886:  BSF    0A.3
0887:  MOVF   7A,W
0888:  MOVWF  2A
0889:  MOVF   79,W
088A:  MOVWF  29
088B:  MOVF   78,W
088C:  MOVWF  28
088D:  MOVF   77,W
088E:  MOVWF  27
....................       temperatura = 20.0 * voltajeTemperatura; 
088F:  CLRF   58
0890:  CLRF   57
0891:  MOVLW  20
0892:  MOVWF  56
0893:  MOVLW  83
0894:  MOVWF  55
0895:  MOVF   2A,W
0896:  MOVWF  5C
0897:  MOVF   29,W
0898:  MOVWF  5B
0899:  MOVF   28,W
089A:  MOVWF  5A
089B:  MOVF   27,W
089C:  MOVWF  59
089D:  BCF    0A.3
089E:  CALL   0AE
089F:  BSF    0A.3
08A0:  MOVF   7A,W
08A1:  MOVWF  2E
08A2:  MOVF   79,W
08A3:  MOVWF  2D
08A4:  MOVF   78,W
08A5:  MOVWF  2C
08A6:  MOVF   77,W
08A7:  MOVWF  2B
....................       printf("[Temperatura] -> %2.2f \r\n", floor(temperatura)); 
08A8:  MOVF   2E,W
08A9:  MOVWF  44
08AA:  MOVF   2D,W
08AB:  MOVWF  43
08AC:  MOVF   2C,W
08AD:  MOVWF  42
08AE:  MOVF   2B,W
08AF:  MOVWF  41
08B0:  BCF    0A.3
08B1:  GOTO   38C
08B2:  BSF    0A.3
08B3:  MOVF   77,W
08B4:  MOVWF  41
08B5:  MOVF   78,W
08B6:  MOVWF  42
08B7:  MOVF   79,W
08B8:  MOVWF  43
08B9:  MOVF   7A,W
08BA:  MOVWF  44
08BB:  MOVLW  15
08BC:  BSF    03.6
08BD:  MOVWF  0D
08BE:  MOVLW  00
08BF:  MOVWF  0F
08C0:  BCF    03.0
08C1:  MOVLW  11
08C2:  BCF    03.6
08C3:  MOVWF  45
08C4:  BCF    0A.3
08C5:  CALL   528
08C6:  BSF    0A.3
08C7:  MOVLW  89
08C8:  MOVWF  04
08C9:  MOVF   44,W
08CA:  MOVWF  48
08CB:  MOVF   43,W
08CC:  MOVWF  47
08CD:  MOVF   42,W
08CE:  MOVWF  46
08CF:  MOVF   41,W
08D0:  MOVWF  45
08D1:  MOVLW  02
08D2:  MOVWF  49
08D3:  BCF    0A.3
08D4:  CALL   5BA
08D5:  BSF    0A.3
08D6:  MOVLW  20
08D7:  BTFSS  0C.4
08D8:  GOTO   0D7
08D9:  MOVWF  19
08DA:  MOVLW  0D
08DB:  BTFSS  0C.4
08DC:  GOTO   0DB
08DD:  MOVWF  19
08DE:  MOVLW  0A
08DF:  BTFSS  0C.4
08E0:  GOTO   0DF
08E1:  MOVWF  19
....................  
....................       //Humedad 
....................       set_adc_channel(0); 
08E2:  MOVLW  00
08E3:  MOVWF  78
08E4:  MOVF   1F,W
08E5:  ANDLW  C7
08E6:  IORWF  78,W
08E7:  MOVWF  1F
....................       delay_us(10); 
08E8:  MOVLW  03
08E9:  MOVWF  77
08EA:  DECFSZ 77,F
08EB:  GOTO   0EA
....................       LSB = read_adc(); 
08EC:  BSF    1F.2
08ED:  BTFSC  1F.2
08EE:  GOTO   0ED
08EF:  BSF    03.5
08F0:  MOVF   1E,W
08F1:  BCF    03.5
08F2:  MOVWF  3D
08F3:  MOVF   1E,W
08F4:  MOVWF  3E
....................       voltajeHS = (LSB * 5.0) / 1023.0; 
08F5:  MOVF   3E,W
08F6:  MOVWF  5A
08F7:  MOVF   3D,W
08F8:  MOVWF  59
08F9:  BCF    0A.3
08FA:  CALL   091
08FB:  BSF    0A.3
08FC:  MOVF   7A,W
08FD:  MOVWF  58
08FE:  MOVF   79,W
08FF:  MOVWF  57
0900:  MOVF   78,W
0901:  MOVWF  56
0902:  MOVF   77,W
0903:  MOVWF  55
0904:  CLRF   5C
0905:  CLRF   5B
0906:  MOVLW  20
0907:  MOVWF  5A
0908:  MOVLW  81
0909:  MOVWF  59
090A:  BCF    0A.3
090B:  CALL   0AE
090C:  BSF    0A.3
090D:  MOVF   77,W
090E:  MOVWF  41
090F:  MOVF   78,W
0910:  MOVWF  42
0911:  MOVF   79,W
0912:  MOVWF  43
0913:  MOVF   7A,W
0914:  MOVWF  44
0915:  MOVWF  58
0916:  MOVF   43,W
0917:  MOVWF  57
0918:  MOVF   42,W
0919:  MOVWF  56
091A:  MOVF   41,W
091B:  MOVWF  55
091C:  CLRF   5C
091D:  MOVLW  C0
091E:  MOVWF  5B
091F:  MOVLW  7F
0920:  MOVWF  5A
0921:  MOVLW  88
0922:  MOVWF  59
0923:  BCF    0A.3
0924:  CALL   123
0925:  BSF    0A.3
0926:  MOVF   7A,W
0927:  MOVWF  32
0928:  MOVF   79,W
0929:  MOVWF  31
092A:  MOVF   78,W
092B:  MOVWF  30
092C:  MOVF   77,W
092D:  MOVWF  2F
....................       HS = voltajeHS * (85.0/4.9) + 10; 
092E:  MOVF   32,W
092F:  MOVWF  58
0930:  MOVF   31,W
0931:  MOVWF  57
0932:  MOVF   30,W
0933:  MOVWF  56
0934:  MOVF   2F,W
0935:  MOVWF  55
0936:  MOVLW  88
0937:  MOVWF  5C
0938:  MOVLW  C6
0939:  MOVWF  5B
093A:  MOVLW  0A
093B:  MOVWF  5A
093C:  MOVLW  83
093D:  MOVWF  59
093E:  BCF    0A.3
093F:  CALL   0AE
0940:  BSF    0A.3
0941:  MOVF   77,W
0942:  MOVWF  41
0943:  MOVF   78,W
0944:  MOVWF  42
0945:  MOVF   79,W
0946:  MOVWF  43
0947:  MOVF   7A,W
0948:  MOVWF  44
0949:  BCF    03.1
094A:  MOVF   44,W
094B:  MOVWF  5C
094C:  MOVF   43,W
094D:  MOVWF  5B
094E:  MOVF   42,W
094F:  MOVWF  5A
0950:  MOVF   41,W
0951:  MOVWF  59
0952:  CLRF   60
0953:  CLRF   5F
0954:  MOVLW  20
0955:  MOVWF  5E
0956:  MOVLW  82
0957:  MOVWF  5D
0958:  BCF    0A.3
0959:  CALL   24B
095A:  BSF    0A.3
095B:  MOVF   7A,W
095C:  MOVWF  36
095D:  MOVF   79,W
095E:  MOVWF  35
095F:  MOVF   78,W
0960:  MOVWF  34
0961:  MOVF   77,W
0962:  MOVWF  33
....................       printf("[Porciento HS] -> %2.2f \r\n", HS); 
0963:  MOVLW  22
0964:  BSF    03.6
0965:  MOVWF  0D
0966:  MOVLW  00
0967:  MOVWF  0F
0968:  BCF    03.0
0969:  MOVLW  12
096A:  BCF    03.6
096B:  MOVWF  45
096C:  BCF    0A.3
096D:  CALL   528
096E:  BSF    0A.3
096F:  MOVLW  89
0970:  MOVWF  04
0971:  MOVF   36,W
0972:  MOVWF  48
0973:  MOVF   35,W
0974:  MOVWF  47
0975:  MOVF   34,W
0976:  MOVWF  46
0977:  MOVF   33,W
0978:  MOVWF  45
0979:  MOVLW  02
097A:  MOVWF  49
097B:  BCF    0A.3
097C:  CALL   5BA
097D:  BSF    0A.3
097E:  MOVLW  20
097F:  BTFSS  0C.4
0980:  GOTO   17F
0981:  MOVWF  19
0982:  MOVLW  0D
0983:  BTFSS  0C.4
0984:  GOTO   183
0985:  MOVWF  19
0986:  MOVLW  0A
0987:  BTFSS  0C.4
0988:  GOTO   187
0989:  MOVWF  19
....................  
....................       //US 
....................       set_pwm1_duty(duty); 
098A:  MOVF   3C,W
098B:  MOVWF  79
098C:  MOVF   3B,W
098D:  MOVWF  78
098E:  RRF    79,F
098F:  RRF    78,F
0990:  RRF    79,F
0991:  RRF    78,F
0992:  RRF    79,F
0993:  MOVF   78,W
0994:  MOVWF  15
0995:  RRF    79,F
0996:  RRF    79,W
0997:  ANDLW  30
0998:  MOVWF  77
0999:  MOVF   17,W
099A:  ANDLW  CF
099B:  IORWF  77,W
099C:  MOVWF  17
....................  
....................       output_high(trigger); 
099D:  BSF    03.5
099E:  BCF    06.1
099F:  BCF    03.5
09A0:  BSF    06.1
....................       delay_us(10); 
09A1:  MOVLW  03
09A2:  MOVWF  77
09A3:  DECFSZ 77,F
09A4:  GOTO   1A3
....................       output_low(trigger); 
09A5:  BSF    03.5
09A6:  BCF    06.1
09A7:  BCF    03.5
09A8:  BCF    06.1
....................  
....................       while (!input(echo)); 
09A9:  BSF    03.5
09AA:  BSF    06.0
09AB:  BCF    03.5
09AC:  BTFSS  06.0
09AD:  GOTO   1A9
....................       set_timer1 (0); 
09AE:  CLRF   0F
09AF:  CLRF   0E
....................  
....................       while (input (echo)); 
09B0:  BSF    03.5
09B1:  BSF    06.0
09B2:  BCF    03.5
09B3:  BTFSC  06.0
09B4:  GOTO   1B0
....................       tiempo=get_timer1(); 
09B5:  MOVF   0F,W
09B6:  MOVWF  7A
09B7:  MOVF   0E,W
09B8:  MOVWF  77
09B9:  MOVF   0F,W
09BA:  SUBWF  7A,W
09BB:  BTFSS  03.2
09BC:  GOTO   1B5
09BD:  MOVF   77,W
09BE:  MOVWF  59
09BF:  MOVF   7A,W
09C0:  MOVWF  5A
09C1:  BCF    0A.3
09C2:  CALL   091
09C3:  BSF    0A.3
09C4:  MOVF   7A,W
09C5:  MOVWF  3A
09C6:  MOVF   79,W
09C7:  MOVWF  39
09C8:  MOVF   78,W
09C9:  MOVWF  38
09CA:  MOVF   77,W
09CB:  MOVWF  37
....................       distancia=(tiempo/2)*(.0343); 
09CC:  MOVF   3A,W
09CD:  MOVWF  58
09CE:  MOVF   39,W
09CF:  MOVWF  57
09D0:  MOVF   38,W
09D1:  MOVWF  56
09D2:  MOVF   37,W
09D3:  MOVWF  55
09D4:  CLRF   5C
09D5:  CLRF   5B
09D6:  CLRF   5A
09D7:  MOVLW  80
09D8:  MOVWF  59
09D9:  BCF    0A.3
09DA:  CALL   123
09DB:  BSF    0A.3
09DC:  MOVF   77,W
09DD:  MOVWF  41
09DE:  MOVF   78,W
09DF:  MOVWF  42
09E0:  MOVF   79,W
09E1:  MOVWF  43
09E2:  MOVF   7A,W
09E3:  MOVWF  44
09E4:  MOVWF  58
09E5:  MOVF   43,W
09E6:  MOVWF  57
09E7:  MOVF   42,W
09E8:  MOVWF  56
09E9:  MOVF   41,W
09EA:  MOVWF  55
09EB:  MOVLW  28
09EC:  MOVWF  5C
09ED:  MOVLW  7E
09EE:  MOVWF  5B
09EF:  MOVLW  0C
09F0:  MOVWF  5A
09F1:  MOVLW  7A
09F2:  MOVWF  59
09F3:  BCF    0A.3
09F4:  CALL   0AE
09F5:  BSF    0A.3
09F6:  MOVF   7A,W
09F7:  MOVWF  26
09F8:  MOVF   79,W
09F9:  MOVWF  25
09FA:  MOVF   78,W
09FB:  MOVWF  24
09FC:  MOVF   77,W
09FD:  MOVWF  23
....................  
....................       printf("[Distancia] -> %f cm\r\n", distancia); 
09FE:  MOVLW  30
09FF:  BSF    03.6
0A00:  MOVWF  0D
0A01:  MOVLW  00
0A02:  MOVWF  0F
0A03:  BCF    03.0
0A04:  MOVLW  0F
0A05:  BCF    03.6
0A06:  MOVWF  45
0A07:  BCF    0A.3
0A08:  CALL   528
0A09:  BSF    0A.3
0A0A:  MOVLW  89
0A0B:  MOVWF  04
0A0C:  MOVF   26,W
0A0D:  MOVWF  48
0A0E:  MOVF   25,W
0A0F:  MOVWF  47
0A10:  MOVF   24,W
0A11:  MOVWF  46
0A12:  MOVF   23,W
0A13:  MOVWF  45
0A14:  MOVLW  02
0A15:  MOVWF  49
0A16:  BCF    0A.3
0A17:  CALL   5BA
0A18:  BSF    0A.3
0A19:  MOVLW  38
0A1A:  BSF    03.6
0A1B:  MOVWF  0D
0A1C:  MOVLW  00
0A1D:  MOVWF  0F
0A1E:  BSF    03.0
0A1F:  MOVLW  05
0A20:  BCF    03.6
0A21:  MOVWF  45
0A22:  BCF    0A.3
0A23:  CALL   528
0A24:  BSF    0A.3
....................       printf("[Tiempo] -> %f seg\r\n", tiempo); 
0A25:  MOVLW  3C
0A26:  BSF    03.6
0A27:  MOVWF  0D
0A28:  MOVLW  00
0A29:  MOVWF  0F
0A2A:  BCF    03.0
0A2B:  MOVLW  0C
0A2C:  BCF    03.6
0A2D:  MOVWF  45
0A2E:  BCF    0A.3
0A2F:  CALL   528
0A30:  BSF    0A.3
0A31:  MOVLW  89
0A32:  MOVWF  04
0A33:  MOVF   3A,W
0A34:  MOVWF  48
0A35:  MOVF   39,W
0A36:  MOVWF  47
0A37:  MOVF   38,W
0A38:  MOVWF  46
0A39:  MOVF   37,W
0A3A:  MOVWF  45
0A3B:  MOVLW  02
0A3C:  MOVWF  49
0A3D:  BCF    0A.3
0A3E:  CALL   5BA
0A3F:  BSF    0A.3
0A40:  MOVLW  43
0A41:  BSF    03.6
0A42:  MOVWF  0D
0A43:  MOVLW  00
0A44:  MOVWF  0F
0A45:  BCF    03.0
0A46:  MOVLW  06
0A47:  BCF    03.6
0A48:  MOVWF  45
0A49:  BCF    0A.3
0A4A:  CALL   528
0A4B:  BSF    0A.3
....................  
....................       delay_us(10); 
0A4C:  MOVLW  03
0A4D:  MOVWF  77
0A4E:  DECFSZ 77,F
0A4F:  GOTO   24E
....................  
....................       if (distancia<= (3.5)) { 
0A50:  MOVF   26,W
0A51:  MOVWF  58
0A52:  MOVF   25,W
0A53:  MOVWF  57
0A54:  MOVF   24,W
0A55:  MOVWF  56
0A56:  MOVF   23,W
0A57:  MOVWF  55
0A58:  CLRF   5C
0A59:  CLRF   5B
0A5A:  MOVLW  60
0A5B:  MOVWF  5A
0A5C:  MOVLW  80
0A5D:  MOVWF  59
0A5E:  BCF    0A.3
0A5F:  CALL   1ED
0A60:  BSF    0A.3
0A61:  BTFSC  03.0
0A62:  GOTO   265
0A63:  BTFSS  03.2
0A64:  GOTO   268
....................          duty=0; 
0A65:  CLRF   3C
0A66:  CLRF   3B
....................       } 
....................       else if ( distancia>=331) { 
0A67:  GOTO   2A3
0A68:  CLRF   58
0A69:  MOVLW  80
0A6A:  MOVWF  57
0A6B:  MOVLW  25
0A6C:  MOVWF  56
0A6D:  MOVLW  87
0A6E:  MOVWF  55
0A6F:  MOVF   26,W
0A70:  MOVWF  5C
0A71:  MOVF   25,W
0A72:  MOVWF  5B
0A73:  MOVF   24,W
0A74:  MOVWF  5A
0A75:  MOVF   23,W
0A76:  MOVWF  59
0A77:  BCF    0A.3
0A78:  CALL   1ED
0A79:  BSF    0A.3
0A7A:  BTFSC  03.0
0A7B:  GOTO   27E
0A7C:  BTFSS  03.2
0A7D:  GOTO   283
....................          duty=331*3; 
0A7E:  MOVLW  03
0A7F:  MOVWF  3C
0A80:  MOVLW  E1
0A81:  MOVWF  3B
....................       } 
....................       else { 
0A82:  GOTO   2A3
....................          duty=distancia*3; 
0A83:  MOVF   26,W
0A84:  MOVWF  58
0A85:  MOVF   25,W
0A86:  MOVWF  57
0A87:  MOVF   24,W
0A88:  MOVWF  56
0A89:  MOVF   23,W
0A8A:  MOVWF  55
0A8B:  CLRF   5C
0A8C:  CLRF   5B
0A8D:  MOVLW  40
0A8E:  MOVWF  5A
0A8F:  MOVLW  80
0A90:  MOVWF  59
0A91:  BCF    0A.3
0A92:  CALL   0AE
0A93:  BSF    0A.3
0A94:  MOVF   7A,W
0A95:  MOVWF  58
0A96:  MOVF   79,W
0A97:  MOVWF  57
0A98:  MOVF   78,W
0A99:  MOVWF  56
0A9A:  MOVF   77,W
0A9B:  MOVWF  55
0A9C:  BCF    0A.3
0A9D:  CALL   22C
0A9E:  BSF    0A.3
0A9F:  MOVF   79,W
0AA0:  MOVWF  3C
0AA1:  MOVF   78,W
0AA2:  MOVWF  3B
....................       } 
....................       delay_us(10); 
0AA3:  MOVLW  03
0AA4:  MOVWF  77
0AA5:  DECFSZ 77,F
0AA6:  GOTO   2A5
....................    } 
0AA7:  GOTO   03A
.................... } 
0AA8:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
