CCS PCM C Compiler, Version 4.104, 5967               18-jun.-21 20:32

               Filename: C:\Users\Abraham\Documents\GitHub\Instru\Proyecto final\final\final.lst

               ROM used: 2411 words (29%)
                         Largest free fragment is 2048
               RAM used: 42 (11%) at main() level
                         78 (21%) worst case
               Stack:    2 locations

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f877a.h> // biblioteca del micro 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device adc=10 //adc de 10 bits 
.................... #include <stdio.h> //input output c 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0813:  BCF    03.5
0814:  CLRF   20
0815:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <math.h> //floor  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
03AA:  BCF    54.0
....................    y = x; 
03AB:  MOVF   48,W
03AC:  MOVWF  4D
03AD:  MOVF   47,W
03AE:  MOVWF  4C
03AF:  MOVF   46,W
03B0:  MOVWF  4B
03B1:  MOVF   45,W
03B2:  MOVWF  4A
....................  
....................    if (x < 0) 
03B3:  MOVF   48,W
03B4:  MOVWF  58
03B5:  MOVF   47,W
03B6:  MOVWF  57
03B7:  MOVF   46,W
03B8:  MOVWF  56
03B9:  MOVF   45,W
03BA:  MOVWF  55
03BB:  CLRF   5C
03BC:  CLRF   5B
03BD:  CLRF   5A
03BE:  CLRF   59
03BF:  CALL   202
03C0:  BTFSS  03.0
03C1:  GOTO   3C6
....................    { 
....................       s = 1; 
03C2:  BSF    54.0
....................       y = -y; 
03C3:  MOVF   4B,W
03C4:  XORLW  80
03C5:  MOVWF  4B
....................    } 
....................  
....................    if (y <= 32768.0) 
03C6:  MOVF   4D,W
03C7:  MOVWF  58
03C8:  MOVF   4C,W
03C9:  MOVWF  57
03CA:  MOVF   4B,W
03CB:  MOVWF  56
03CC:  MOVF   4A,W
03CD:  MOVWF  55
03CE:  CLRF   5C
03CF:  CLRF   5B
03D0:  CLRF   5A
03D1:  MOVLW  8E
03D2:  MOVWF  59
03D3:  CALL   202
03D4:  BTFSC  03.0
03D5:  GOTO   3D8
03D6:  BTFSS  03.2
03D7:  GOTO   3EF
....................   res = (float32)(unsigned int16)y; 
03D8:  MOVF   4D,W
03D9:  MOVWF  58
03DA:  MOVF   4C,W
03DB:  MOVWF  57
03DC:  MOVF   4B,W
03DD:  MOVWF  56
03DE:  MOVF   4A,W
03DF:  MOVWF  55
03E0:  CALL   241
03E1:  MOVF   79,W
03E2:  MOVWF  5A
03E3:  MOVF   78,W
03E4:  MOVWF  59
03E5:  CALL   0A6
03E6:  MOVF   7A,W
03E7:  MOVWF  51
03E8:  MOVF   79,W
03E9:  MOVWF  50
03EA:  MOVF   78,W
03EB:  MOVWF  4F
03EC:  MOVF   77,W
03ED:  MOVWF  4E
....................  
....................  else if (y < 10000000.0) 
03EE:  GOTO   4AC
03EF:  MOVF   4D,W
03F0:  MOVWF  58
03F1:  MOVF   4C,W
03F2:  MOVWF  57
03F3:  MOVF   4B,W
03F4:  MOVWF  56
03F5:  MOVF   4A,W
03F6:  MOVWF  55
03F7:  MOVLW  80
03F8:  MOVWF  5C
03F9:  MOVLW  96
03FA:  MOVWF  5B
03FB:  MOVLW  18
03FC:  MOVWF  5A
03FD:  MOVLW  96
03FE:  MOVWF  59
03FF:  CALL   202
0400:  BTFSS  03.0
0401:  GOTO   4A4
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
0402:  MOVF   4D,W
0403:  MOVWF  58
0404:  MOVF   4C,W
0405:  MOVWF  57
0406:  MOVF   4B,W
0407:  MOVWF  56
0408:  MOVF   4A,W
0409:  MOVWF  55
040A:  CLRF   5C
040B:  CLRF   5B
040C:  CLRF   5A
040D:  MOVLW  8E
040E:  MOVWF  59
040F:  CALL   138
0410:  MOVF   7A,W
0411:  MOVWF  58
0412:  MOVF   79,W
0413:  MOVWF  57
0414:  MOVF   78,W
0415:  MOVWF  56
0416:  MOVF   77,W
0417:  MOVWF  55
0418:  CALL   241
0419:  MOVF   79,W
041A:  MOVWF  53
041B:  MOVF   78,W
041C:  MOVWF  52
....................       y = 32768.0*(y/32768.0 - (float32)l); 
041D:  MOVF   4D,W
041E:  MOVWF  58
041F:  MOVF   4C,W
0420:  MOVWF  57
0421:  MOVF   4B,W
0422:  MOVWF  56
0423:  MOVF   4A,W
0424:  MOVWF  55
0425:  CLRF   5C
0426:  CLRF   5B
0427:  CLRF   5A
0428:  MOVLW  8E
0429:  MOVWF  59
042A:  CALL   138
042B:  MOVF   77,W
042C:  MOVWF  55
042D:  MOVF   78,W
042E:  MOVWF  56
042F:  MOVF   79,W
0430:  MOVWF  57
0431:  MOVF   7A,W
0432:  MOVWF  58
0433:  MOVF   53,W
0434:  MOVWF  5A
0435:  MOVF   52,W
0436:  MOVWF  59
0437:  CALL   0A6
0438:  BSF    03.1
0439:  MOVF   58,W
043A:  MOVWF  5C
043B:  MOVF   57,W
043C:  MOVWF  5B
043D:  MOVF   56,W
043E:  MOVWF  5A
043F:  MOVF   55,W
0440:  MOVWF  59
0441:  MOVF   7A,W
0442:  MOVWF  60
0443:  MOVF   79,W
0444:  MOVWF  5F
0445:  MOVF   78,W
0446:  MOVWF  5E
0447:  MOVF   77,W
0448:  MOVWF  5D
0449:  CALL   260
044A:  CLRF   58
044B:  CLRF   57
044C:  CLRF   56
044D:  MOVLW  8E
044E:  MOVWF  55
044F:  MOVF   7A,W
0450:  MOVWF  5C
0451:  MOVF   79,W
0452:  MOVWF  5B
0453:  MOVF   78,W
0454:  MOVWF  5A
0455:  MOVF   77,W
0456:  MOVWF  59
0457:  CALL   0C3
0458:  MOVF   7A,W
0459:  MOVWF  4D
045A:  MOVF   79,W
045B:  MOVWF  4C
045C:  MOVF   78,W
045D:  MOVWF  4B
045E:  MOVF   77,W
045F:  MOVWF  4A
....................   res = 32768.0*(float32)l; 
0460:  MOVF   53,W
0461:  MOVWF  5A
0462:  MOVF   52,W
0463:  MOVWF  59
0464:  CALL   0A6
0465:  CLRF   58
0466:  CLRF   57
0467:  CLRF   56
0468:  MOVLW  8E
0469:  MOVWF  55
046A:  MOVF   7A,W
046B:  MOVWF  5C
046C:  MOVF   79,W
046D:  MOVWF  5B
046E:  MOVF   78,W
046F:  MOVWF  5A
0470:  MOVF   77,W
0471:  MOVWF  59
0472:  CALL   0C3
0473:  MOVF   7A,W
0474:  MOVWF  51
0475:  MOVF   79,W
0476:  MOVWF  50
0477:  MOVF   78,W
0478:  MOVWF  4F
0479:  MOVF   77,W
047A:  MOVWF  4E
....................   res += (float32)(unsigned int16)y; 
047B:  MOVF   4D,W
047C:  MOVWF  58
047D:  MOVF   4C,W
047E:  MOVWF  57
047F:  MOVF   4B,W
0480:  MOVWF  56
0481:  MOVF   4A,W
0482:  MOVWF  55
0483:  CALL   241
0484:  MOVF   79,W
0485:  MOVWF  5A
0486:  MOVF   78,W
0487:  MOVWF  59
0488:  CALL   0A6
0489:  BCF    03.1
048A:  MOVF   51,W
048B:  MOVWF  5C
048C:  MOVF   50,W
048D:  MOVWF  5B
048E:  MOVF   4F,W
048F:  MOVWF  5A
0490:  MOVF   4E,W
0491:  MOVWF  59
0492:  MOVF   7A,W
0493:  MOVWF  60
0494:  MOVF   79,W
0495:  MOVWF  5F
0496:  MOVF   78,W
0497:  MOVWF  5E
0498:  MOVF   77,W
0499:  MOVWF  5D
049A:  CALL   260
049B:  MOVF   7A,W
049C:  MOVWF  51
049D:  MOVF   79,W
049E:  MOVWF  50
049F:  MOVF   78,W
04A0:  MOVWF  4F
04A1:  MOVF   77,W
04A2:  MOVWF  4E
....................  } 
....................  
....................  else 
04A3:  GOTO   4AC
....................   res = y; 
04A4:  MOVF   4D,W
04A5:  MOVWF  51
04A6:  MOVF   4C,W
04A7:  MOVWF  50
04A8:  MOVF   4B,W
04A9:  MOVWF  4F
04AA:  MOVF   4A,W
04AB:  MOVWF  4E
....................  
....................  y = y - (float32)(unsigned int16)y; 
04AC:  MOVF   4D,W
04AD:  MOVWF  58
04AE:  MOVF   4C,W
04AF:  MOVWF  57
04B0:  MOVF   4B,W
04B1:  MOVWF  56
04B2:  MOVF   4A,W
04B3:  MOVWF  55
04B4:  CALL   241
04B5:  MOVF   79,W
04B6:  MOVWF  5A
04B7:  MOVF   78,W
04B8:  MOVWF  59
04B9:  CALL   0A6
04BA:  BSF    03.1
04BB:  MOVF   4D,W
04BC:  MOVWF  5C
04BD:  MOVF   4C,W
04BE:  MOVWF  5B
04BF:  MOVF   4B,W
04C0:  MOVWF  5A
04C1:  MOVF   4A,W
04C2:  MOVWF  59
04C3:  MOVF   7A,W
04C4:  MOVWF  60
04C5:  MOVF   79,W
04C6:  MOVWF  5F
04C7:  MOVF   78,W
04C8:  MOVWF  5E
04C9:  MOVF   77,W
04CA:  MOVWF  5D
04CB:  CALL   260
04CC:  MOVF   7A,W
04CD:  MOVWF  4D
04CE:  MOVF   79,W
04CF:  MOVWF  4C
04D0:  MOVF   78,W
04D1:  MOVWF  4B
04D2:  MOVF   77,W
04D3:  MOVWF  4A
....................  
....................  if (s) 
04D4:  BTFSS  54.0
04D5:  GOTO   4D9
....................   res = -res; 
04D6:  MOVF   4F,W
04D7:  XORLW  80
04D8:  MOVWF  4F
....................  
....................  if (y != 0) 
04D9:  MOVF   4D,W
04DA:  MOVWF  58
04DB:  MOVF   4C,W
04DC:  MOVWF  57
04DD:  MOVF   4B,W
04DE:  MOVWF  56
04DF:  MOVF   4A,W
04E0:  MOVWF  55
04E1:  CLRF   5C
04E2:  CLRF   5B
04E3:  CLRF   5A
04E4:  CLRF   59
04E5:  CALL   202
04E6:  BTFSC  03.2
04E7:  GOTO   51F
....................  { 
....................   if (s == 1 && n == 0) 
04E8:  BTFSS  54.0
04E9:  GOTO   504
04EA:  MOVF   49,F
04EB:  BTFSS  03.2
04EC:  GOTO   504
....................    res -= 1.0; 
04ED:  BSF    03.1
04EE:  MOVF   51,W
04EF:  MOVWF  5C
04F0:  MOVF   50,W
04F1:  MOVWF  5B
04F2:  MOVF   4F,W
04F3:  MOVWF  5A
04F4:  MOVF   4E,W
04F5:  MOVWF  59
04F6:  CLRF   60
04F7:  CLRF   5F
04F8:  CLRF   5E
04F9:  MOVLW  7F
04FA:  MOVWF  5D
04FB:  CALL   260
04FC:  MOVF   7A,W
04FD:  MOVWF  51
04FE:  MOVF   79,W
04FF:  MOVWF  50
0500:  MOVF   78,W
0501:  MOVWF  4F
0502:  MOVF   77,W
0503:  MOVWF  4E
....................  
....................   if (s == 0 && n == 1) 
0504:  BTFSC  54.0
0505:  GOTO   51F
0506:  DECFSZ 49,W
0507:  GOTO   51F
....................    res += 1.0; 
0508:  BCF    03.1
0509:  MOVF   51,W
050A:  MOVWF  5C
050B:  MOVF   50,W
050C:  MOVWF  5B
050D:  MOVF   4F,W
050E:  MOVWF  5A
050F:  MOVF   4E,W
0510:  MOVWF  59
0511:  CLRF   60
0512:  CLRF   5F
0513:  CLRF   5E
0514:  MOVLW  7F
0515:  MOVWF  5D
0516:  CALL   260
0517:  MOVF   7A,W
0518:  MOVWF  51
0519:  MOVF   79,W
051A:  MOVWF  50
051B:  MOVF   78,W
051C:  MOVWF  4F
051D:  MOVF   77,W
051E:  MOVWF  4E
....................  } 
....................  if (x == 0) 
051F:  MOVF   48,W
0520:  MOVWF  58
0521:  MOVF   47,W
0522:  MOVWF  57
0523:  MOVF   46,W
0524:  MOVWF  56
0525:  MOVF   45,W
0526:  MOVWF  55
0527:  CLRF   5C
0528:  CLRF   5B
0529:  CLRF   5A
052A:  CLRF   59
052B:  CALL   202
052C:  BTFSS  03.2
052D:  GOTO   532
....................     res = 0; 
052E:  CLRF   51
052F:  CLRF   50
0530:  CLRF   4F
0531:  CLRF   4E
....................  
....................  return (res); 
0532:  MOVF   4E,W
0533:  MOVWF  77
0534:  MOVF   4F,W
0535:  MOVWF  78
0536:  MOVF   50,W
0537:  MOVWF  79
0538:  MOVF   51,W
0539:  MOVWF  7A
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
03A1:  MOVF   44,W
03A2:  MOVWF  48
03A3:  MOVF   43,W
03A4:  MOVWF  47
03A5:  MOVF   42,W
03A6:  MOVWF  46
03A7:  MOVF   41,W
03A8:  MOVWF  45
03A9:  CLRF   49
.................... } 
*
053A:  BSF    0A.3
053B:  BCF    0A.4
053C:  GOTO   0B3 (RETURN)
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, PUT, BROWNOUT 
.................... #use delay (clock = 4MHz) // XT = 4MHz 
*
0091:  MOVLW  42
0092:  MOVWF  04
0093:  BCF    03.7
0094:  MOVF   00,W
0095:  BTFSC  03.2
0096:  GOTO   0A5
0097:  MOVLW  01
0098:  MOVWF  78
0099:  CLRF   77
009A:  DECFSZ 77,F
009B:  GOTO   09A
009C:  DECFSZ 78,F
009D:  GOTO   099
009E:  MOVLW  4A
009F:  MOVWF  77
00A0:  DECFSZ 77,F
00A1:  GOTO   0A0
00A2:  GOTO   0A3
00A3:  DECFSZ 00,F
00A4:  GOTO   097
00A5:  RETURN
.................... #use rs232 (baud = 9600, parity = N, xmit = pin_c6, rcv = pin_c7, bits = 8 ) // configuracin del puerto serial 
....................  
.................... #define echo PIN_B0 
.................... #define trigger PIN_B1 
....................  
.................... void main () { 
*
0046:  DATA 00,00
*
0800:  CLRF   04
0801:  BCF    03.7
0802:  MOVLW  1F
0803:  ANDWF  03,F
0804:  MOVLW  19
0805:  BSF    03.5
0806:  MOVWF  19
0807:  MOVLW  A6
0808:  MOVWF  18
0809:  MOVLW  90
080A:  BCF    03.5
080B:  MOVWF  18
080C:  BSF    03.5
080D:  BSF    1F.0
080E:  BSF    1F.1
080F:  BSF    1F.2
0810:  BCF    1F.3
0811:  MOVLW  07
0812:  MOVWF  1C
....................  
....................    float distancia, voltajeTemperatura, temperatura, voltajeHS, HS; 
....................    double tiempo; 
....................    int16 duty, LSB; 
....................    int Timer2, poscaler; 
....................  
....................    setup_adc_ports(all_analog); 
*
0818:  BSF    03.5
0819:  BCF    1F.0
081A:  BCF    1F.1
081B:  BCF    1F.2
081C:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_internal); 
081D:  BCF    1F.6
081E:  BCF    03.5
081F:  BSF    1F.6
0820:  BSF    1F.7
0821:  BSF    03.5
0822:  BSF    1F.7
0823:  BCF    03.5
0824:  BSF    1F.0
....................  
....................    setup_timer_1(T1_internal|T1_div_by_1); 
0825:  MOVLW  85
0826:  MOVWF  10
....................    Timer2=249; 
0827:  MOVLW  F9
0828:  MOVWF  3F
....................  
....................    poscaler=1; 
0829:  MOVLW  01
082A:  MOVWF  40
....................    set_tris_c(0b11111110); 
082B:  MOVLW  FE
082C:  BSF    03.5
082D:  MOVWF  07
082E:  BCF    03.5
082F:  MOVWF  22
....................    setup_ccp1 (ccp_pwm); 
0830:  BCF    22.2
0831:  MOVF   22,W
0832:  BSF    03.5
0833:  MOVWF  07
0834:  BCF    03.5
0835:  BCF    07.2
0836:  MOVLW  0C
0837:  MOVWF  17
....................    duty=0; 
0838:  CLRF   3C
0839:  CLRF   3B
....................  
....................    while (true) { 
....................       printf("-------------------------------\r\n"); 
083A:  MOVLW  04
083B:  BSF    03.6
083C:  MOVWF  0D
083D:  MOVLW  00
083E:  MOVWF  0F
083F:  BCF    0A.3
0840:  BCF    03.6
0841:  GOTO   047
0842:  BSF    0A.3
....................       //Temperatura 
....................       set_adc_channel(1); 
0843:  MOVLW  08
0844:  MOVWF  78
0845:  MOVF   1F,W
0846:  ANDLW  C7
0847:  IORWF  78,W
0848:  MOVWF  1F
....................       delay_ms(100); 
0849:  MOVLW  64
084A:  MOVWF  42
084B:  BCF    0A.3
084C:  CALL   091
084D:  BSF    0A.3
....................       LSB = read_adc(); 
084E:  BSF    1F.2
084F:  BTFSC  1F.2
0850:  GOTO   04F
0851:  BSF    03.5
0852:  MOVF   1E,W
0853:  BCF    03.5
0854:  MOVWF  3D
0855:  MOVF   1E,W
0856:  MOVWF  3E
....................       voltajeTemperatura = (LSB * 5.0) / 1023.0; 
0857:  MOVF   3E,W
0858:  MOVWF  5A
0859:  MOVF   3D,W
085A:  MOVWF  59
085B:  BCF    0A.3
085C:  CALL   0A6
085D:  BSF    0A.3
085E:  MOVF   7A,W
085F:  MOVWF  58
0860:  MOVF   79,W
0861:  MOVWF  57
0862:  MOVF   78,W
0863:  MOVWF  56
0864:  MOVF   77,W
0865:  MOVWF  55
0866:  CLRF   5C
0867:  CLRF   5B
0868:  MOVLW  20
0869:  MOVWF  5A
086A:  MOVLW  81
086B:  MOVWF  59
086C:  BCF    0A.3
086D:  CALL   0C3
086E:  BSF    0A.3
086F:  MOVF   77,W
0870:  MOVWF  41
0871:  MOVF   78,W
0872:  MOVWF  42
0873:  MOVF   79,W
0874:  MOVWF  43
0875:  MOVF   7A,W
0876:  MOVWF  44
0877:  MOVWF  58
0878:  MOVF   43,W
0879:  MOVWF  57
087A:  MOVF   42,W
087B:  MOVWF  56
087C:  MOVF   41,W
087D:  MOVWF  55
087E:  CLRF   5C
087F:  MOVLW  C0
0880:  MOVWF  5B
0881:  MOVLW  7F
0882:  MOVWF  5A
0883:  MOVLW  88
0884:  MOVWF  59
0885:  BCF    0A.3
0886:  CALL   138
0887:  BSF    0A.3
0888:  MOVF   7A,W
0889:  MOVWF  2A
088A:  MOVF   79,W
088B:  MOVWF  29
088C:  MOVF   78,W
088D:  MOVWF  28
088E:  MOVF   77,W
088F:  MOVWF  27
....................       temperatura = 20.0 * voltajeTemperatura; 
0890:  CLRF   58
0891:  CLRF   57
0892:  MOVLW  20
0893:  MOVWF  56
0894:  MOVLW  83
0895:  MOVWF  55
0896:  MOVF   2A,W
0897:  MOVWF  5C
0898:  MOVF   29,W
0899:  MOVWF  5B
089A:  MOVF   28,W
089B:  MOVWF  5A
089C:  MOVF   27,W
089D:  MOVWF  59
089E:  BCF    0A.3
089F:  CALL   0C3
08A0:  BSF    0A.3
08A1:  MOVF   7A,W
08A2:  MOVWF  2E
08A3:  MOVF   79,W
08A4:  MOVWF  2D
08A5:  MOVF   78,W
08A6:  MOVWF  2C
08A7:  MOVF   77,W
08A8:  MOVWF  2B
....................       printf("[Temperatura] -> %2.2f \r\n", floor(temperatura)); 
08A9:  MOVF   2E,W
08AA:  MOVWF  44
08AB:  MOVF   2D,W
08AC:  MOVWF  43
08AD:  MOVF   2C,W
08AE:  MOVWF  42
08AF:  MOVF   2B,W
08B0:  MOVWF  41
08B1:  BCF    0A.3
08B2:  GOTO   3A1
08B3:  BSF    0A.3
08B4:  MOVF   77,W
08B5:  MOVWF  41
08B6:  MOVF   78,W
08B7:  MOVWF  42
08B8:  MOVF   79,W
08B9:  MOVWF  43
08BA:  MOVF   7A,W
08BB:  MOVWF  44
08BC:  MOVLW  15
08BD:  BSF    03.6
08BE:  MOVWF  0D
08BF:  MOVLW  00
08C0:  MOVWF  0F
08C1:  BCF    03.0
08C2:  MOVLW  11
08C3:  BCF    03.6
08C4:  MOVWF  45
08C5:  BCF    0A.3
08C6:  CALL   53D
08C7:  BSF    0A.3
08C8:  MOVLW  89
08C9:  MOVWF  04
08CA:  MOVF   44,W
08CB:  MOVWF  48
08CC:  MOVF   43,W
08CD:  MOVWF  47
08CE:  MOVF   42,W
08CF:  MOVWF  46
08D0:  MOVF   41,W
08D1:  MOVWF  45
08D2:  MOVLW  02
08D3:  MOVWF  49
08D4:  BCF    0A.3
08D5:  CALL   5CF
08D6:  BSF    0A.3
08D7:  MOVLW  20
08D8:  BTFSS  0C.4
08D9:  GOTO   0D8
08DA:  MOVWF  19
08DB:  MOVLW  0D
08DC:  BTFSS  0C.4
08DD:  GOTO   0DC
08DE:  MOVWF  19
08DF:  MOVLW  0A
08E0:  BTFSS  0C.4
08E1:  GOTO   0E0
08E2:  MOVWF  19
....................  
....................       //Humedad 
....................       set_adc_channel(0); 
08E3:  MOVLW  00
08E4:  MOVWF  78
08E5:  MOVF   1F,W
08E6:  ANDLW  C7
08E7:  IORWF  78,W
08E8:  MOVWF  1F
....................       delay_ms(100); 
08E9:  MOVLW  64
08EA:  MOVWF  42
08EB:  BCF    0A.3
08EC:  CALL   091
08ED:  BSF    0A.3
....................       LSB = read_adc(); 
08EE:  BSF    1F.2
08EF:  BTFSC  1F.2
08F0:  GOTO   0EF
08F1:  BSF    03.5
08F2:  MOVF   1E,W
08F3:  BCF    03.5
08F4:  MOVWF  3D
08F5:  MOVF   1E,W
08F6:  MOVWF  3E
....................       voltajeHS = (LSB * 5.0) / 1023.0; 
08F7:  MOVF   3E,W
08F8:  MOVWF  5A
08F9:  MOVF   3D,W
08FA:  MOVWF  59
08FB:  BCF    0A.3
08FC:  CALL   0A6
08FD:  BSF    0A.3
08FE:  MOVF   7A,W
08FF:  MOVWF  58
0900:  MOVF   79,W
0901:  MOVWF  57
0902:  MOVF   78,W
0903:  MOVWF  56
0904:  MOVF   77,W
0905:  MOVWF  55
0906:  CLRF   5C
0907:  CLRF   5B
0908:  MOVLW  20
0909:  MOVWF  5A
090A:  MOVLW  81
090B:  MOVWF  59
090C:  BCF    0A.3
090D:  CALL   0C3
090E:  BSF    0A.3
090F:  MOVF   77,W
0910:  MOVWF  41
0911:  MOVF   78,W
0912:  MOVWF  42
0913:  MOVF   79,W
0914:  MOVWF  43
0915:  MOVF   7A,W
0916:  MOVWF  44
0917:  MOVWF  58
0918:  MOVF   43,W
0919:  MOVWF  57
091A:  MOVF   42,W
091B:  MOVWF  56
091C:  MOVF   41,W
091D:  MOVWF  55
091E:  CLRF   5C
091F:  MOVLW  C0
0920:  MOVWF  5B
0921:  MOVLW  7F
0922:  MOVWF  5A
0923:  MOVLW  88
0924:  MOVWF  59
0925:  BCF    0A.3
0926:  CALL   138
0927:  BSF    0A.3
0928:  MOVF   7A,W
0929:  MOVWF  32
092A:  MOVF   79,W
092B:  MOVWF  31
092C:  MOVF   78,W
092D:  MOVWF  30
092E:  MOVF   77,W
092F:  MOVWF  2F
....................       HS = voltajeHS * (85.0/4.9) + 10; 
0930:  MOVF   32,W
0931:  MOVWF  58
0932:  MOVF   31,W
0933:  MOVWF  57
0934:  MOVF   30,W
0935:  MOVWF  56
0936:  MOVF   2F,W
0937:  MOVWF  55
0938:  MOVLW  88
0939:  MOVWF  5C
093A:  MOVLW  C6
093B:  MOVWF  5B
093C:  MOVLW  0A
093D:  MOVWF  5A
093E:  MOVLW  83
093F:  MOVWF  59
0940:  BCF    0A.3
0941:  CALL   0C3
0942:  BSF    0A.3
0943:  MOVF   77,W
0944:  MOVWF  41
0945:  MOVF   78,W
0946:  MOVWF  42
0947:  MOVF   79,W
0948:  MOVWF  43
0949:  MOVF   7A,W
094A:  MOVWF  44
094B:  BCF    03.1
094C:  MOVF   44,W
094D:  MOVWF  5C
094E:  MOVF   43,W
094F:  MOVWF  5B
0950:  MOVF   42,W
0951:  MOVWF  5A
0952:  MOVF   41,W
0953:  MOVWF  59
0954:  CLRF   60
0955:  CLRF   5F
0956:  MOVLW  20
0957:  MOVWF  5E
0958:  MOVLW  82
0959:  MOVWF  5D
095A:  BCF    0A.3
095B:  CALL   260
095C:  BSF    0A.3
095D:  MOVF   7A,W
095E:  MOVWF  36
095F:  MOVF   79,W
0960:  MOVWF  35
0961:  MOVF   78,W
0962:  MOVWF  34
0963:  MOVF   77,W
0964:  MOVWF  33
....................       printf("[Porciento HS] -> %2.2f \r\n", HS); 
0965:  MOVLW  22
0966:  BSF    03.6
0967:  MOVWF  0D
0968:  MOVLW  00
0969:  MOVWF  0F
096A:  BCF    03.0
096B:  MOVLW  12
096C:  BCF    03.6
096D:  MOVWF  45
096E:  BCF    0A.3
096F:  CALL   53D
0970:  BSF    0A.3
0971:  MOVLW  89
0972:  MOVWF  04
0973:  MOVF   36,W
0974:  MOVWF  48
0975:  MOVF   35,W
0976:  MOVWF  47
0977:  MOVF   34,W
0978:  MOVWF  46
0979:  MOVF   33,W
097A:  MOVWF  45
097B:  MOVLW  02
097C:  MOVWF  49
097D:  BCF    0A.3
097E:  CALL   5CF
097F:  BSF    0A.3
0980:  MOVLW  20
0981:  BTFSS  0C.4
0982:  GOTO   181
0983:  MOVWF  19
0984:  MOVLW  0D
0985:  BTFSS  0C.4
0986:  GOTO   185
0987:  MOVWF  19
0988:  MOVLW  0A
0989:  BTFSS  0C.4
098A:  GOTO   189
098B:  MOVWF  19
....................  
....................       //US 
....................       set_pwm1_duty(duty); 
098C:  MOVF   3C,W
098D:  MOVWF  79
098E:  MOVF   3B,W
098F:  MOVWF  78
0990:  RRF    79,F
0991:  RRF    78,F
0992:  RRF    79,F
0993:  RRF    78,F
0994:  RRF    79,F
0995:  MOVF   78,W
0996:  MOVWF  15
0997:  RRF    79,F
0998:  RRF    79,W
0999:  ANDLW  30
099A:  MOVWF  77
099B:  MOVF   17,W
099C:  ANDLW  CF
099D:  IORWF  77,W
099E:  MOVWF  17
....................  
....................       output_high(trigger); 
099F:  BSF    03.5
09A0:  BCF    06.1
09A1:  BCF    03.5
09A2:  BSF    06.1
....................       delay_us(10); 
09A3:  MOVLW  03
09A4:  MOVWF  77
09A5:  DECFSZ 77,F
09A6:  GOTO   1A5
....................       output_low(trigger); 
09A7:  BSF    03.5
09A8:  BCF    06.1
09A9:  BCF    03.5
09AA:  BCF    06.1
....................  
....................       while (!input(echo)); 
09AB:  BSF    03.5
09AC:  BSF    06.0
09AD:  BCF    03.5
09AE:  BTFSS  06.0
09AF:  GOTO   1AB
....................       set_timer1 (0); 
09B0:  CLRF   0F
09B1:  CLRF   0E
....................  
....................       while (input (echo)); 
09B2:  BSF    03.5
09B3:  BSF    06.0
09B4:  BCF    03.5
09B5:  BTFSC  06.0
09B6:  GOTO   1B2
....................       tiempo=get_timer1(); 
09B7:  MOVF   0F,W
09B8:  MOVWF  7A
09B9:  MOVF   0E,W
09BA:  MOVWF  77
09BB:  MOVF   0F,W
09BC:  SUBWF  7A,W
09BD:  BTFSS  03.2
09BE:  GOTO   1B7
09BF:  MOVF   77,W
09C0:  MOVWF  59
09C1:  MOVF   7A,W
09C2:  MOVWF  5A
09C3:  BCF    0A.3
09C4:  CALL   0A6
09C5:  BSF    0A.3
09C6:  MOVF   7A,W
09C7:  MOVWF  3A
09C8:  MOVF   79,W
09C9:  MOVWF  39
09CA:  MOVF   78,W
09CB:  MOVWF  38
09CC:  MOVF   77,W
09CD:  MOVWF  37
....................       distancia=(tiempo/2)*(.0343); 
09CE:  MOVF   3A,W
09CF:  MOVWF  58
09D0:  MOVF   39,W
09D1:  MOVWF  57
09D2:  MOVF   38,W
09D3:  MOVWF  56
09D4:  MOVF   37,W
09D5:  MOVWF  55
09D6:  CLRF   5C
09D7:  CLRF   5B
09D8:  CLRF   5A
09D9:  MOVLW  80
09DA:  MOVWF  59
09DB:  BCF    0A.3
09DC:  CALL   138
09DD:  BSF    0A.3
09DE:  MOVF   77,W
09DF:  MOVWF  41
09E0:  MOVF   78,W
09E1:  MOVWF  42
09E2:  MOVF   79,W
09E3:  MOVWF  43
09E4:  MOVF   7A,W
09E5:  MOVWF  44
09E6:  MOVWF  58
09E7:  MOVF   43,W
09E8:  MOVWF  57
09E9:  MOVF   42,W
09EA:  MOVWF  56
09EB:  MOVF   41,W
09EC:  MOVWF  55
09ED:  MOVLW  28
09EE:  MOVWF  5C
09EF:  MOVLW  7E
09F0:  MOVWF  5B
09F1:  MOVLW  0C
09F2:  MOVWF  5A
09F3:  MOVLW  7A
09F4:  MOVWF  59
09F5:  BCF    0A.3
09F6:  CALL   0C3
09F7:  BSF    0A.3
09F8:  MOVF   7A,W
09F9:  MOVWF  26
09FA:  MOVF   79,W
09FB:  MOVWF  25
09FC:  MOVF   78,W
09FD:  MOVWF  24
09FE:  MOVF   77,W
09FF:  MOVWF  23
....................  
....................       printf("[Distancia] -> %f cm\r\n", distancia); 
0A00:  MOVLW  30
0A01:  BSF    03.6
0A02:  MOVWF  0D
0A03:  MOVLW  00
0A04:  MOVWF  0F
0A05:  BCF    03.0
0A06:  MOVLW  0F
0A07:  BCF    03.6
0A08:  MOVWF  45
0A09:  BCF    0A.3
0A0A:  CALL   53D
0A0B:  BSF    0A.3
0A0C:  MOVLW  89
0A0D:  MOVWF  04
0A0E:  MOVF   26,W
0A0F:  MOVWF  48
0A10:  MOVF   25,W
0A11:  MOVWF  47
0A12:  MOVF   24,W
0A13:  MOVWF  46
0A14:  MOVF   23,W
0A15:  MOVWF  45
0A16:  MOVLW  02
0A17:  MOVWF  49
0A18:  BCF    0A.3
0A19:  CALL   5CF
0A1A:  BSF    0A.3
0A1B:  MOVLW  38
0A1C:  BSF    03.6
0A1D:  MOVWF  0D
0A1E:  MOVLW  00
0A1F:  MOVWF  0F
0A20:  BSF    03.0
0A21:  MOVLW  05
0A22:  BCF    03.6
0A23:  MOVWF  45
0A24:  BCF    0A.3
0A25:  CALL   53D
0A26:  BSF    0A.3
....................       printf("[Tiempo] -> %f seg\r\n", tiempo); 
0A27:  MOVLW  3C
0A28:  BSF    03.6
0A29:  MOVWF  0D
0A2A:  MOVLW  00
0A2B:  MOVWF  0F
0A2C:  BCF    03.0
0A2D:  MOVLW  0C
0A2E:  BCF    03.6
0A2F:  MOVWF  45
0A30:  BCF    0A.3
0A31:  CALL   53D
0A32:  BSF    0A.3
0A33:  MOVLW  89
0A34:  MOVWF  04
0A35:  MOVF   3A,W
0A36:  MOVWF  48
0A37:  MOVF   39,W
0A38:  MOVWF  47
0A39:  MOVF   38,W
0A3A:  MOVWF  46
0A3B:  MOVF   37,W
0A3C:  MOVWF  45
0A3D:  MOVLW  02
0A3E:  MOVWF  49
0A3F:  BCF    0A.3
0A40:  CALL   5CF
0A41:  BSF    0A.3
0A42:  MOVLW  43
0A43:  BSF    03.6
0A44:  MOVWF  0D
0A45:  MOVLW  00
0A46:  MOVWF  0F
0A47:  BCF    03.0
0A48:  MOVLW  06
0A49:  BCF    03.6
0A4A:  MOVWF  45
0A4B:  BCF    0A.3
0A4C:  CALL   53D
0A4D:  BSF    0A.3
....................  
....................       delay_ms(500); 
0A4E:  MOVLW  02
0A4F:  MOVWF  41
0A50:  MOVLW  FA
0A51:  MOVWF  42
0A52:  BCF    0A.3
0A53:  CALL   091
0A54:  BSF    0A.3
0A55:  DECFSZ 41,F
0A56:  GOTO   250
....................        
....................       if (distancia<= (3.5)) { 
0A57:  MOVF   26,W
0A58:  MOVWF  58
0A59:  MOVF   25,W
0A5A:  MOVWF  57
0A5B:  MOVF   24,W
0A5C:  MOVWF  56
0A5D:  MOVF   23,W
0A5E:  MOVWF  55
0A5F:  CLRF   5C
0A60:  CLRF   5B
0A61:  MOVLW  60
0A62:  MOVWF  5A
0A63:  MOVLW  80
0A64:  MOVWF  59
0A65:  BCF    0A.3
0A66:  CALL   202
0A67:  BSF    0A.3
0A68:  BTFSC  03.0
0A69:  GOTO   26C
0A6A:  BTFSS  03.2
0A6B:  GOTO   26F
....................          duty=0; 
0A6C:  CLRF   3C
0A6D:  CLRF   3B
....................       } 
....................       else if ( distancia>=331) { 
0A6E:  GOTO   2AA
0A6F:  CLRF   58
0A70:  MOVLW  80
0A71:  MOVWF  57
0A72:  MOVLW  25
0A73:  MOVWF  56
0A74:  MOVLW  87
0A75:  MOVWF  55
0A76:  MOVF   26,W
0A77:  MOVWF  5C
0A78:  MOVF   25,W
0A79:  MOVWF  5B
0A7A:  MOVF   24,W
0A7B:  MOVWF  5A
0A7C:  MOVF   23,W
0A7D:  MOVWF  59
0A7E:  BCF    0A.3
0A7F:  CALL   202
0A80:  BSF    0A.3
0A81:  BTFSC  03.0
0A82:  GOTO   285
0A83:  BTFSS  03.2
0A84:  GOTO   28A
....................          duty=331*3; 
0A85:  MOVLW  03
0A86:  MOVWF  3C
0A87:  MOVLW  E1
0A88:  MOVWF  3B
....................       } 
....................       else { 
0A89:  GOTO   2AA
....................          duty=distancia*3; 
0A8A:  MOVF   26,W
0A8B:  MOVWF  58
0A8C:  MOVF   25,W
0A8D:  MOVWF  57
0A8E:  MOVF   24,W
0A8F:  MOVWF  56
0A90:  MOVF   23,W
0A91:  MOVWF  55
0A92:  CLRF   5C
0A93:  CLRF   5B
0A94:  MOVLW  40
0A95:  MOVWF  5A
0A96:  MOVLW  80
0A97:  MOVWF  59
0A98:  BCF    0A.3
0A99:  CALL   0C3
0A9A:  BSF    0A.3
0A9B:  MOVF   7A,W
0A9C:  MOVWF  58
0A9D:  MOVF   79,W
0A9E:  MOVWF  57
0A9F:  MOVF   78,W
0AA0:  MOVWF  56
0AA1:  MOVF   77,W
0AA2:  MOVWF  55
0AA3:  BCF    0A.3
0AA4:  CALL   241
0AA5:  BSF    0A.3
0AA6:  MOVF   79,W
0AA7:  MOVWF  3C
0AA8:  MOVF   78,W
0AA9:  MOVWF  3B
....................       } 
....................       delay_ms(200); 
0AAA:  MOVLW  C8
0AAB:  MOVWF  42
0AAC:  BCF    0A.3
0AAD:  CALL   091
0AAE:  BSF    0A.3
....................    } 
0AAF:  GOTO   03A
.................... } 
0AB0:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
